"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-blockies";
exports.ids = ["vendor-chunks/react-blockies"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-blockies/dist/main.js":
/*!**************************************************!*\
  !*** ./node_modules/react-blockies/dist/main.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Identicon = function (_Component) {\n  _inherits(Identicon, _Component);\n\n  function Identicon(props) {\n    _classCallCheck(this, Identicon);\n\n    var _this = _possibleConstructorReturn(this, (Identicon.__proto__ || Object.getPrototypeOf(Identicon)).call(this, props));\n\n    _this.generateIdenticon = _this.generateIdenticon.bind(_this);\n    return _this;\n  }\n\n  _createClass(Identicon, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.generateIdenticon(_extends({}, this.props));\n    }\n  }, {\n    key: 'componentWillUpdate',\n    value: function componentWillUpdate(nextProps) {\n      if (!this.isEquivalent(this.props, nextProps)) this.generateIdenticon(_extends({}, nextProps));\n    }\n  }, {\n    key: 'isEquivalent',\n    value: function isEquivalent(prevProps, nextProps) {\n      var aProps = Object.getOwnPropertyNames(prevProps);\n      var bProps = Object.getOwnPropertyNames(nextProps);\n\n      if (aProps.length != bProps.length) {\n        return false;\n      }\n\n      for (var i = 0; i < aProps.length; i++) {\n        var propName = aProps[i];\n\n        if (prevProps[propName] !== nextProps[propName]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'generateIdenticon',\n    value: function generateIdenticon(options) {\n      // NOTE --  Majority of this code is referenced from: https://github.com/alexvandesande/blockies\n      //          Mostly to ensure congruence to Ethereum Mist's Identicons\n\n      // The random number is a js implementation of the Xorshift PRNG\n      var randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values\n\n      function seedrand(seed) {\n        for (var i = 0; i < randseed.length; i++) {\n          randseed[i] = 0;\n        }\n        for (var _i = 0; _i < seed.length; _i++) {\n          randseed[_i % 4] = (randseed[_i % 4] << 5) - randseed[_i % 4] + seed.charCodeAt(_i);\n        }\n      }\n\n      function rand() {\n        // based on Java's String.hashCode(), expanded to 4 32bit values\n        var t = randseed[0] ^ randseed[0] << 11;\n\n        randseed[0] = randseed[1];\n        randseed[1] = randseed[2];\n        randseed[2] = randseed[3];\n        randseed[3] = randseed[3] ^ randseed[3] >> 19 ^ t ^ t >> 8;\n\n        return (randseed[3] >>> 0) / (1 << 31 >>> 0);\n      }\n\n      function createColor() {\n        // saturation is the whole color spectrum\n        var h = Math.floor(rand() * 360);\n        // saturation goes from 40 to 100, it avoids greyish colors\n        var s = rand() * 60 + 40 + '%';\n        // lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%\n        var l = (rand() + rand() + rand() + rand()) * 25 + '%';\n\n        var color = 'hsl(' + h + ',' + s + ',' + l + ')';\n        return color;\n      }\n\n      function createImageData(size) {\n        var width = size; // Only support square icons for now\n        var height = size;\n\n        var dataWidth = Math.ceil(width / 2);\n        var mirrorWidth = width - dataWidth;\n\n        var data = [];\n        for (var y = 0; y < height; y++) {\n          var row = [];\n          for (var x = 0; x < dataWidth; x++) {\n            // this makes foreground and background color to have a 43% (1/2.3) probability\n            // spot color has 13% chance\n            row[x] = Math.floor(rand() * 2.3);\n          }\n          var r = row.slice(0, mirrorWidth);\n          r.reverse();\n          row = row.concat(r);\n\n          for (var i = 0; i < row.length; i++) {\n            data.push(row[i]);\n          }\n        }\n\n        return data;\n      }\n\n      function setCanvas(identicon, imageData, color, scale, bgcolor, spotcolor) {\n        var width = Math.sqrt(imageData.length);\n        var size = width * scale;\n\n        identicon.width = size;\n        identicon.style.width = size + 'px';\n\n        identicon.height = size;\n        identicon.style.height = size + 'px';\n\n        var cc = identicon.getContext('2d');\n        cc.fillStyle = bgcolor;\n        cc.fillRect(0, 0, identicon.width, identicon.height);\n        cc.fillStyle = color;\n\n        for (var i = 0; i < imageData.length; i++) {\n          // if data is 2, choose spot color, if 1 choose foreground\n          cc.fillStyle = imageData[i] === 1 ? color : spotcolor;\n\n          // if data is 0, leave the background\n          if (imageData[i]) {\n            var row = Math.floor(i / width);\n            var col = i % width;\n\n            cc.fillRect(col * scale, row * scale, scale, scale);\n          }\n        }\n      }\n\n      var opts = options || {};\n      var size = opts.size || 8;\n      var scale = opts.scale || 4;\n      var seed = opts.seed || Math.floor(Math.random() * Math.pow(10, 16)).toString(16);\n\n      seedrand(seed);\n\n      var color = opts.color || createColor();\n      var bgcolor = opts.bgColor || createColor();\n      var spotcolor = opts.spotColor || createColor();\n      var imageData = createImageData(size);\n      var canvas = setCanvas(this.identicon, imageData, color, scale, bgcolor, spotcolor);\n\n      return canvas;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      return _react2.default.createElement('canvas', {\n        ref: function ref(identicon) {\n          _this2.identicon = identicon;\n        },\n        className: this.props.className\n      });\n    }\n  }]);\n\n  return Identicon;\n}(_react.Component);\n\nexports[\"default\"] = Identicon;\n\n\nIdenticon.defaultProps = {\n  className: 'identicon'\n};\n\nIdenticon.propTypes = {\n  seed: _propTypes2.default.string.isRequired,\n  size: _propTypes2.default.number,\n  scale: _propTypes2.default.number,\n  color: _propTypes2.default.string,\n  bgColor: _propTypes2.default.string,\n  spotColor: _propTypes2.default.string\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYmxvY2tpZXMvZGlzdC9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQzs7QUFFRixvREFBb0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQzs7QUFFaFAsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixhQUFhLG1CQUFPLENBQUMsd0dBQU87O0FBRTVCOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZOztBQUVyQzs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSxrREFBa0QsMENBQTBDOztBQUU1RixrREFBa0QsYUFBYSx5RkFBeUY7O0FBRXhKLDJDQUEyQywrREFBK0QsdUdBQXVHLHlFQUF5RSxlQUFlLDBFQUEwRSxHQUFHOztBQUV0WDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBZTs7O0FBR2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ibG9ja2llcy9kaXN0L21haW4uanM/NzIyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIElkZW50aWNvbiA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhJZGVudGljb24sIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIElkZW50aWNvbihwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZGVudGljb24pO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKElkZW50aWNvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50aWNvbikpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLmdlbmVyYXRlSWRlbnRpY29uID0gX3RoaXMuZ2VuZXJhdGVJZGVudGljb24uYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElkZW50aWNvbiwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlkZW50aWNvbihfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpKSB0aGlzLmdlbmVyYXRlSWRlbnRpY29uKF9leHRlbmRzKHt9LCBuZXh0UHJvcHMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0VxdWl2YWxlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWl2YWxlbnQocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBhUHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcmV2UHJvcHMpO1xuICAgICAgdmFyIGJQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG5leHRQcm9wcyk7XG5cbiAgICAgIGlmIChhUHJvcHMubGVuZ3RoICE9IGJQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBhUHJvcHNbaV07XG5cbiAgICAgICAgaWYgKHByZXZQcm9wc1twcm9wTmFtZV0gIT09IG5leHRQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2VuZXJhdGVJZGVudGljb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUlkZW50aWNvbihvcHRpb25zKSB7XG4gICAgICAvLyBOT1RFIC0tICBNYWpvcml0eSBvZiB0aGlzIGNvZGUgaXMgcmVmZXJlbmNlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vYWxleHZhbmRlc2FuZGUvYmxvY2tpZXNcbiAgICAgIC8vICAgICAgICAgIE1vc3RseSB0byBlbnN1cmUgY29uZ3J1ZW5jZSB0byBFdGhlcmV1bSBNaXN0J3MgSWRlbnRpY29uc1xuXG4gICAgICAvLyBUaGUgcmFuZG9tIG51bWJlciBpcyBhIGpzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBYb3JzaGlmdCBQUk5HXG4gICAgICB2YXIgcmFuZHNlZWQgPSBuZXcgQXJyYXkoNCk7IC8vIFhvcnNoaWZ0OiBbeCwgeSwgeiwgd10gMzIgYml0IHZhbHVlc1xuXG4gICAgICBmdW5jdGlvbiBzZWVkcmFuZChzZWVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZHNlZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByYW5kc2VlZFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNlZWQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgcmFuZHNlZWRbX2kgJSA0XSA9IChyYW5kc2VlZFtfaSAlIDRdIDw8IDUpIC0gcmFuZHNlZWRbX2kgJSA0XSArIHNlZWQuY2hhckNvZGVBdChfaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmFuZCgpIHtcbiAgICAgICAgLy8gYmFzZWQgb24gSmF2YSdzIFN0cmluZy5oYXNoQ29kZSgpLCBleHBhbmRlZCB0byA0IDMyYml0IHZhbHVlc1xuICAgICAgICB2YXIgdCA9IHJhbmRzZWVkWzBdIF4gcmFuZHNlZWRbMF0gPDwgMTE7XG5cbiAgICAgICAgcmFuZHNlZWRbMF0gPSByYW5kc2VlZFsxXTtcbiAgICAgICAgcmFuZHNlZWRbMV0gPSByYW5kc2VlZFsyXTtcbiAgICAgICAgcmFuZHNlZWRbMl0gPSByYW5kc2VlZFszXTtcbiAgICAgICAgcmFuZHNlZWRbM10gPSByYW5kc2VlZFszXSBeIHJhbmRzZWVkWzNdID4+IDE5IF4gdCBeIHQgPj4gODtcblxuICAgICAgICByZXR1cm4gKHJhbmRzZWVkWzNdID4+PiAwKSAvICgxIDw8IDMxID4+PiAwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ29sb3IoKSB7XG4gICAgICAgIC8vIHNhdHVyYXRpb24gaXMgdGhlIHdob2xlIGNvbG9yIHNwZWN0cnVtXG4gICAgICAgIHZhciBoID0gTWF0aC5mbG9vcihyYW5kKCkgKiAzNjApO1xuICAgICAgICAvLyBzYXR1cmF0aW9uIGdvZXMgZnJvbSA0MCB0byAxMDAsIGl0IGF2b2lkcyBncmV5aXNoIGNvbG9yc1xuICAgICAgICB2YXIgcyA9IHJhbmQoKSAqIDYwICsgNDAgKyAnJSc7XG4gICAgICAgIC8vIGxpZ2h0bmVzcyBjYW4gYmUgYW55dGhpbmcgZnJvbSAwIHRvIDEwMCwgYnV0IHByb2JhYmlsaXRpZXMgYXJlIGEgYmVsbCBjdXJ2ZSBhcm91bmQgNTAlXG4gICAgICAgIHZhciBsID0gKHJhbmQoKSArIHJhbmQoKSArIHJhbmQoKSArIHJhbmQoKSkgKiAyNSArICclJztcblxuICAgICAgICB2YXIgY29sb3IgPSAnaHNsKCcgKyBoICsgJywnICsgcyArICcsJyArIGwgKyAnKSc7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhKHNpemUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gc2l6ZTsgLy8gT25seSBzdXBwb3J0IHNxdWFyZSBpY29ucyBmb3Igbm93XG4gICAgICAgIHZhciBoZWlnaHQgPSBzaXplO1xuXG4gICAgICAgIHZhciBkYXRhV2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyAyKTtcbiAgICAgICAgdmFyIG1pcnJvcldpZHRoID0gd2lkdGggLSBkYXRhV2lkdGg7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRhdGFXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1ha2VzIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgdG8gaGF2ZSBhIDQzJSAoMS8yLjMpIHByb2JhYmlsaXR5XG4gICAgICAgICAgICAvLyBzcG90IGNvbG9yIGhhcyAxMyUgY2hhbmNlXG4gICAgICAgICAgICByb3dbeF0gPSBNYXRoLmZsb29yKHJhbmQoKSAqIDIuMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByID0gcm93LnNsaWNlKDAsIG1pcnJvcldpZHRoKTtcbiAgICAgICAgICByLnJldmVyc2UoKTtcbiAgICAgICAgICByb3cgPSByb3cuY29uY2F0KHIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChyb3dbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRDYW52YXMoaWRlbnRpY29uLCBpbWFnZURhdGEsIGNvbG9yLCBzY2FsZSwgYmdjb2xvciwgc3BvdGNvbG9yKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGguc3FydChpbWFnZURhdGEubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNpemUgPSB3aWR0aCAqIHNjYWxlO1xuXG4gICAgICAgIGlkZW50aWNvbi53aWR0aCA9IHNpemU7XG4gICAgICAgIGlkZW50aWNvbi5zdHlsZS53aWR0aCA9IHNpemUgKyAncHgnO1xuXG4gICAgICAgIGlkZW50aWNvbi5oZWlnaHQgPSBzaXplO1xuICAgICAgICBpZGVudGljb24uc3R5bGUuaGVpZ2h0ID0gc2l6ZSArICdweCc7XG5cbiAgICAgICAgdmFyIGNjID0gaWRlbnRpY29uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNjLmZpbGxTdHlsZSA9IGJnY29sb3I7XG4gICAgICAgIGNjLmZpbGxSZWN0KDAsIDAsIGlkZW50aWNvbi53aWR0aCwgaWRlbnRpY29uLmhlaWdodCk7XG4gICAgICAgIGNjLmZpbGxTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gaWYgZGF0YSBpcyAyLCBjaG9vc2Ugc3BvdCBjb2xvciwgaWYgMSBjaG9vc2UgZm9yZWdyb3VuZFxuICAgICAgICAgIGNjLmZpbGxTdHlsZSA9IGltYWdlRGF0YVtpXSA9PT0gMSA/IGNvbG9yIDogc3BvdGNvbG9yO1xuXG4gICAgICAgICAgLy8gaWYgZGF0YSBpcyAwLCBsZWF2ZSB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgIGlmIChpbWFnZURhdGFbaV0pIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKGkgLyB3aWR0aCk7XG4gICAgICAgICAgICB2YXIgY29sID0gaSAlIHdpZHRoO1xuXG4gICAgICAgICAgICBjYy5maWxsUmVjdChjb2wgKiBzY2FsZSwgcm93ICogc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBzaXplID0gb3B0cy5zaXplIHx8IDg7XG4gICAgICB2YXIgc2NhbGUgPSBvcHRzLnNjYWxlIHx8IDQ7XG4gICAgICB2YXIgc2VlZCA9IG9wdHMuc2VlZCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgMTYpKS50b1N0cmluZygxNik7XG5cbiAgICAgIHNlZWRyYW5kKHNlZWQpO1xuXG4gICAgICB2YXIgY29sb3IgPSBvcHRzLmNvbG9yIHx8IGNyZWF0ZUNvbG9yKCk7XG4gICAgICB2YXIgYmdjb2xvciA9IG9wdHMuYmdDb2xvciB8fCBjcmVhdGVDb2xvcigpO1xuICAgICAgdmFyIHNwb3Rjb2xvciA9IG9wdHMuc3BvdENvbG9yIHx8IGNyZWF0ZUNvbG9yKCk7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY3JlYXRlSW1hZ2VEYXRhKHNpemUpO1xuICAgICAgdmFyIGNhbnZhcyA9IHNldENhbnZhcyh0aGlzLmlkZW50aWNvbiwgaW1hZ2VEYXRhLCBjb2xvciwgc2NhbGUsIGJnY29sb3IsIHNwb3Rjb2xvcik7XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnY2FudmFzJywge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihpZGVudGljb24pIHtcbiAgICAgICAgICBfdGhpczIuaWRlbnRpY29uID0gaWRlbnRpY29uO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSWRlbnRpY29uO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSWRlbnRpY29uO1xuXG5cbklkZW50aWNvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJ2lkZW50aWNvbidcbn07XG5cbklkZW50aWNvbi5wcm9wVHlwZXMgPSB7XG4gIHNlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNpemU6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBzY2FsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gIGNvbG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgYmdDb2xvcjogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIHNwb3RDb2xvcjogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmdcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-blockies/dist/main.js\n");

/***/ })

};
;